<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Meteor Impact Simulator — Single File (Completed)</title>

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>

<style>
  :root{--panel-bg:#111827;--panel-fg:#e5e7eb;--accent:#06b6d4}
  html,body,#map{height:100%;margin:0;padding:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  body{display:grid;grid-template-columns:340px 1fr 360px;gap:8px;align-items:stretch;background:#0b1220;color:var(--panel-fg)}
  .panel{padding:12px;background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));border-radius:8px;box-shadow:0 4px 18px rgba(2,6,23,0.6);overflow:auto}
  .left{height:100vh}
  .right{height:100vh}
  h2{margin:4px 0 12px;font-size:16px}
  label{display:block;font-size:13px;margin-top:8px}
  input[type=range]{width:100%}
  .row{display:flex;gap:8px;align-items:center}
  .btn{background:var(--accent);border:none;color:#022;padding:8px 10px;border-radius:6px;cursor:pointer;font-weight:600}
  .small{font-size:12px;padding:6px 8px}
  .map-wrap{position:relative;height:100vh;border-radius:8px;overflow:hidden}
  #map{height:100%}
  .overlayInfo{position:absolute;left:8px;bottom:8px;background:rgba(0,0,0,0.5);padding:6px;border-radius:6px;font-size:12px}
  .presetItem{display:flex;justify-content:space-between;align-items:center;margin:6px 0;padding:6px;border-radius:6px;background:rgba(255,255,255,0.02)}
  .statBox{background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;margin-bottom:8px}
  canvas{max-width:100%}
  .flex-col{display:flex;flex-direction:column}
  .log{height:160px;overflow:auto;background:rgba(255,255,255,0.02);padding:8px;border-radius:6px}
  .footer{font-size:12px;color:#9ca3af;margin-top:8px}
</style>
</head>
<body>

<div class="panel left">
  <h2>Controls & Presets</h2>

  <div>
    <label>Preset</label>
    <select id="presetSelect"></select>
    <button id="quickLoad" class="btn small" style="margin-top:8px">Quick Load Preset</button>
  </div>

  <hr style="opacity:0.06;margin:12px 0">

  <div class="statBox">
    <h3 style="margin:0;font-size:14px">Custom Meteor Builder</h3>
    <label>Diameter (m) <span id="diamVal">20</span></label>
    <input id="diam" type="range" min="1" max="10000" value="20">

    <label>Shape</label>
    <select id="shape"><option value="spherical">Spherical</option><option value="oblate">Oblate</option><option value="elongated">Elongated</option></select>

    <label>Density (kg/m³) <span id="densVal">3300</span></label>
    <input id="density" type="range" min="200" max="8000" value="3300">

    <label>Velocity (m/s) <span id="velVal">19000</span></label>
    <input id="velocity" type="range" min="1100" max="40000" value="19000">

    <label>Entry angle (deg) <span id="angleVal">18</span></label>
    <input id="angle" type="range" min="5" max="85" value="18">

    <label>Click on the map to place meteor initial location / or enter lat,lng</label>
    <div class="row"><input id="lat" placeholder="lat" style="flex:1;padding:6px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.06)"><input id="lng" placeholder="lng" style="flex:1;padding:6px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.06)"></div>
  </div>

  <div class="statBox">
    <h3 style="margin:0;font-size:14px">Atmosphere & Interceptor</h3>
    <label>Atmospheric density multiplier <span id="atmVal">1.00</span></label>
    <input id="atm" type="range" min="0.1" max="3" step="0.01" value="1">

    <label>Wind speed (m/s)</label>
    <input id="wind" type="range" min="0" max="60" step="1" value="5">

    <label>Interceptor type</label>
    <select id="interceptorType"><option value="none">None</option><option value="kinetic">Kinetic</option><option value="explosive">Explosive</option></select>

    <label>Interceptor energy (TJ) <span id="intVal">0</span></label>
    <input id="intEnergy" type="range" min="0" max="20000" value="0">

    <label>Interceptor altitude (km)</label>
    <input id="intAlt" type="range" min="1" max="120" value="30">
  </div>

  <div class="statBox">
    <h3 style="margin:0;font-size:14px">Population model</h3>
    <label>Population density (people / km²)</label>
    <div class="row"><input id="popDensity" type="number" value="1000" style="flex:1;padding:6px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.06)"><select id="popPreset"><option value="manual">Manual</option><option value="rural">Rural (10)</option><option value="suburban">Suburban (500)</option><option value="urban">Urban (3000)</option></select></div>

    <label>Casualty fractions (annihilation / severe / moderate / light)</label>
    <div class="row" style="gap:4px"><input id="cA" type="number" value="0.98" step="0.01"><input id="cS" type="number" value="0.45" step="0.01"><input id="cM" type="number" value="0.05" step="0.01"><input id="cL" type="number" value="0.005" step="0.001"></div>
  </div>

  <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
    <button id="runBtn" class="btn">Run</button>
    <button id="pauseBtn" class="btn small">Pause</button>
    <button id="stepBtn" class="btn small">Step</button>
    <button id="resetBtn" class="btn small">Reset</button>
  </div>

  <div style="margin-top:12px">
    <button id="exportJson" class="btn small">Export JSON</button>
    <button id="snapshot" class="btn small">Snapshot (PNG)</button>
  </div>

  <div class="footer">Tip: click the map to set location. Presets load typical starting parameters.</div>
</div>

<div class="map-wrap">
  <div id="map"></div>
  <div class="overlayInfo" id="mapInfo">Click to place meteor • Zoom to inspect zones</div>
</div>

<div class="panel right">
  <h2>Results & Timeline</h2>

  <div class="statBox">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <div style="font-size:13px">Initial KE</div>
        <div id="keInit">— J</div>
      </div>
      <div>
        <div style="font-size:13px">Ground KE</div>
        <div id="keGround">— J</div>
      </div>
      <div>
        <div style="font-size:13px">TNT equiv.</div>
        <div id="tntEq">— kt</div>
      </div>
    </div>
  </div>

  <div class="statBox">
    <h3 style="margin:0;font-size:14px">Population affected</h3>
    <div style="display:flex;gap:8px">
      <div style="flex:1">
        <div>Before interception</div>
        <div id="popBefore">—</div>
      </div>
      <div style="flex:1">
        <div>After interception</div>
        <div id="popAfter">—</div>
      </div>
    </div>
  </div>

  <div class="statBox">
    <h3 style="margin:0;font-size:14px">Timeline</h3>
    <canvas id="timelineChart" height="160"></canvas>
  </div>

  <div class="statBox">
    <h3 style="margin:0;font-size:14px">Event log</h3>
    <div id="log" class="log"></div>
  </div>

  <div style="margin-top:8px">
    <small style="color:#9ca3af">Physics: simplified energy/drag/ablation/fragmentation model. Change constants in the source (PHYS) to tune.</small>
  </div>
</div>

<!-- Libraries -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

<script>
/* --------------------- PHYSICS CONSTANTS & TUNABLES --------------------- */
const PHYS = {
  Cd: 1.0,               // drag coefficient
  Lambda: 0.1,           // ablation efficiency constant (tunable)
  Q: 1e7,                // heat of ablation (J/kg) (tunable)
  strength: 1e6,         // material strength threshold (Pa) (typical stony ~1e6)
  dt: 0.05,              // simulation timestep (s)
  airSeaLevelDensity: 1.225, // kg/m^3
  gravity: 9.81,
  minFragmentMass: 1,    // kg, aggregated fragment stop threshold
  tntJ: 4.184e12         // J per kiloton TNT
};

/* --------------------------- PRESETS DATA --------------------------- */
const PRESETS = [
  {id:'chicx', name:'Chicxulub (giant)', D:10000, rho:3000, v:20000, angle:45, material:'rock', lat:21.4, lng:-89.5, desc:'Planet-killer scale preset'},
  {id:'tunguska', name:'Tunguska (1908)', D:80, rho:2500, v:12000, angle:30, material:'stony', lat:60.886, lng:101.9, desc:'Airburst over Siberia'},
  {id:'barringer', name:"Barringer / Meteor Crater", D:50, rho:7800, v:12000, angle:15, material:'iron', lat:35.027, lng:-111.022, desc:'Iron impactor approx.'},
  {id:'chely', name:'Chelyabinsk (2013)', D:20, rho:3300, v:19000, angle:18, material:'stony', lat:55.154, lng:61.429, desc:'Modern city airburst'},
  {id:'sutters', name:"Sutter's Mill (2012)", D:4, rho:3300, v:20000, angle:45, material:'carbonaceous', lat:38.5, lng:-120.8, desc:'Small meteor shower fragment'},
  {id:'vredefort', name:'Vredefort-class (ancient)', D:3000, rho:2700, v:15000, angle:45, material:'rock', lat:-27.0, lng:27.4, desc:'Large basin former impact'},
  {id:'aten', name:'Aten-class small impactor', D:10, rho:2700, v:12000, angle:45, material:'stony', lat:0, lng:0, desc:'Small, local impactor'},
  {id:'comet', name:'Cometary (icy)', D:500, rho:600, v:30000, angle:60, material:'icy', lat:0, lng:0, desc:'Icy comet nucleus preset'},
  {id:'citykiller', name:'Hypothetical city-killer', D:200, rho:3000, v:17000, angle:45, material:'stony', lat:0, lng:0, desc:'Medium city-killer preset'},
  {id:'small', name:'Small fireball (benign)', D:2, rho:3000, v:15000, angle:45, material:'rock', lat:0, lng:0, desc:'Usually airbursts with little ground damage'}
];

/* --------------------------- UTIL & STATE --------------------------- */
let map, meteorMarker=null, entryLayerGroup, blastLayers=[];
let simState = {running:false, paused:false, time:0, data:[], fragments:[], results:null};
let timelineChart;

function logEvent(s){ const box = document.getElementById('log'); box.innerHTML = (new Date()).toLocaleTimeString() + ' — ' + s + '\n' + box.innerHTML; }

/* --------------------------- INIT MAP & UI --------------------------- */
function init(){
  // populate presets
  const ps = document.getElementById('presetSelect'); PRESETS.forEach(p=>{ const o=document.createElement('option'); o.value=p.id; o.textContent=p.name; ps.appendChild(o); });

  // map
  map = L.map('map',{worldCopyJump:false}).setView([20,0],2);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19, attribution:'© OpenStreetMap'}).addTo(map);
  entryLayerGroup = L.layerGroup().addTo(map);

  map.on('click', (e)=>{
    placeMeteorAt(e.latlng.lat, e.latlng.lng);
  });

  // UI inputs binding
  bindInputs();
  initChart();
  resetSimulation();
}

function bindInputs(){
  const diam = document.getElementById('diam'), dens=document.getElementById('density'), vel=document.getElementById('velocity'), ang=document.getElementById('angle');
  const diamVal=document.getElementById('diamVal'), densVal=document.getElementById('densVal'), velVal=document.getElementById('velVal'), angVal=document.getElementById('angleVal');
  diam.oninput = ()=>{ diamVal.textContent=diam.value; }
  dens.oninput = ()=>{ densVal.textContent=dens.value; }
  vel.oninput = ()=>{ velVal.textContent=vel.value; }
  ang.oninput = ()=>{ angVal.textContent=ang.value; }

  document.getElementById('quickLoad').onclick = ()=>{ loadPreset(document.getElementById('presetSelect').value); }
  document.getElementById('presetSelect').onchange = ()=>{};

  document.getElementById('runBtn').onclick = runSimulation;
  document.getElementById('pauseBtn').onclick = ()=> simState.paused=!simState.paused;
  document.getElementById('resetBtn').onclick = resetSimulation;
  document.getElementById('stepBtn').onclick = stepSimulation;
  document.getElementById('exportJson').onclick = exportJSON;
  document.getElementById('snapshot').onclick = takeSnapshot;

  document.getElementById('popPreset').onchange = (e)=>{
    const v=e.target.value; const inp=document.getElementById('popDensity');
    if(v==='rural') inp.value=10; else if(v==='suburban') inp.value=500; else if(v==='urban') inp.value=3000;
  }

  document.getElementById('presetSelect').ondblclick = ()=> loadPreset(document.getElementById('presetSelect').value);
}

/* --------------------------- PRESET LOADER --------------------------- */
function loadPreset(id){ const p=PRESETS.find(x=>x.id===id); if(!p) return; document.getElementById('diam').value=p.D; document.getElementById('diamVal').textContent=p.D; document.getElementById('density').value=p.rho; document.getElementById('densVal').textContent=p.rho; document.getElementById('velocity').value=p.v; document.getElementById('velVal').textContent=p.v; document.getElementById('angle').value=p.angle; document.getElementById('angleVal').textContent=p.angle; if(p.lat!==0||p.lng!==0) placeMeteorAt(p.lat,p.lng); logEvent('Preset loaded: '+p.name); }

/* --------------------------- MAP HELPERS --------------------------- */
function placeMeteorAt(lat,lng){ document.getElementById('lat').value=lat.toFixed(5); document.getElementById('lng').value=lng.toFixed(5); if(meteorMarker) entryLayerGroup.removeLayer(meteorMarker); meteorMarker = L.marker([lat,lng],{title:'Meteor initial location'}).addTo(entryLayerGroup); map.panTo([lat,lng]); logEvent('Meteor placed at '+lat.toFixed(3)+', '+lng.toFixed(3)); }

function clearBlastLayers(){ blastLayers.forEach(l=>map.removeLayer(l)); blastLayers=[]; }

function drawBlast(radius_m, opts={color:'red', fillOpacity:0.15}){
  const lat = parseFloat(document.getElementById('lat').value); const lng = parseFloat(document.getElementById('lng').value);
  if(isNaN(lat)||isNaN(lng)) return;
  const circle = L.circle([lat,lng],{radius:radius_m, color:opts.color, fillOpacity:opts.fillOpacity}).addTo(map);
  blastLayers.push(circle);
}

/* --------------------------- SIMULATION CORE --------------------------- */
function resetSimulation(){ simState={running:false,paused:false,time:0,data:[],fragments:[],results:null}; clearBlastLayers(); document.getElementById('log').innerText=''; document.getElementById('keInit').innerText='— J'; document.getElementById('keGround').innerText='— J'; document.getElementById('tntEq').innerText='— kt'; document.getElementById('popBefore').innerText='—'; document.getElementById('popAfter').innerText='—'; updateChart([]); }

function gatherInput(){
  const D = parseFloat(document.getElementById('diam').value); const rho = parseFloat(document.getElementById('density').value); const v = parseFloat(document.getElementById('velocity').value); const angle_deg = parseFloat(document.getElementById('angle').value); const lat = parseFloat(document.getElementById('lat').value) || 0; const lng = parseFloat(document.getElementById('lng').value) || 0;
  const atmMul = parseFloat(document.getElementById('atm').value); const wind = parseFloat(document.getElementById('wind').value);
  const interceptorType = document.getElementById('interceptorType').value; const intEnergy = parseFloat(document.getElementById('intEnergy').value) * 1e12; const intAlt = parseFloat(document.getElementById('intAlt').value) * 1000;
  const popDensity = parseFloat(document.getElementById('popDensity').value);
  const casualties = {A:parseFloat(document.getElementById('cA').value), S:parseFloat(document.getElementById('cS').value), M:parseFloat(document.getElementById('cM').value), L:parseFloat(document.getElementById('cL').value)};
  return {D,rho,v,angle_deg,lat,lng,atmMul,wind,interceptorType,intEnergy,intAlt,popDensity,casualties};
}

function runSimulation(){ if(simState.running){ logEvent('Simulation already running'); return; } const inpt=gatherInput(); simState.running=true; simState.paused=false; simState.time=0; simState.data=[]; simState.results=null; clearBlastLayers(); logEvent('Simulation started');
  // build initial body
  const shapeFactor = (document.getElementById('shape').value==='spherical')?1.0:((document.getElementById('shape').value==='oblate')?0.9:1.1);
  const volume = Math.PI/6 * Math.pow(inpt.D*shapeFactor,3);
  let mass = volume * inpt.rho;
  const area = Math.PI * Math.pow(inpt.D/2,2) * (shapeFactor*1.0);
  const angle = inpt.angle_deg*Math.PI/180;
  const vx0 = inpt.v * Math.cos(angle); // horizontal speed magnitude
  const vz0 = inpt.v * Math.sin(angle); // vertical speed magnitude
  // starting altitude
  const altitude0 = 120000; // meters

  // initial energy
  const KEinit = 0.5 * mass * inpt.v * inpt.v;
  document.getElementById('keInit').innerText = KEinit.toExponential(3)+ ' J';

  // store initial fragment group (vx positive eastwards, vz positive downward)
  simState.fragments = [{mass:mass, area:area, vx:vx0, vz:vz0, altitude:altitude0, posLat:inpt.lat, posLng:inpt.lng, alive:true, id:0}];

  // interceptor
  const interceptor = {type:inpt.interceptorType, energy:inpt.intEnergy, alt:inpt.intAlt};

  const dt = PHYS.dt;

  function step(){
    if(!simState.running) return;
    if(simState.paused){ requestAnimationFrame(step); return; }

    // take a handful of microsteps to keep stable
    for(let micro=0; micro<5; micro++){
      // copy list since fragmentation mutates
      const fragmentsNow = simState.fragments.slice();
      for(let f of fragmentsNow){
        if(!f.alive) continue;

        // local air density with exponential atmosphere approx
        const H = 8000;
        const atmMul = parseFloat(document.getElementById('atm').value) || 1.0;
        const rhoAir = PHYS.airSeaLevelDensity * atmMul * Math.exp(-f.altitude / H);

        // speed & drag
        const vmag = Math.sqrt(f.vx*f.vx + f.vz*f.vz) + 1e-9;
        const Fd = 0.5 * PHYS.Cd * rhoAir * f.area * vmag*vmag;
        const ax = -Fd * (f.vx / vmag) / f.mass;
        const az = -Fd * (f.vz / vmag) / f.mass + PHYS.gravity; // gravity accelerates downward (vz positive down)

        // update velocities
        f.vx += ax * dt;
        f.vz += az * dt;

        // update position (altitude decreases as it moves downward)
        f.altitude -= f.vz * dt; // since vz is downward positive, subtract to reduce altitude
        // horizontal displacement -> approximate change in longitude only (small-step)
        const dx = f.vx * dt; // meters east
        const dLng = dx / (111320 * Math.cos(f.posLat * Math.PI/180));
        f.posLng += dLng;

        // ablation (energy-limited simplified)
        const dM = - (PHYS.Lambda * f.area * rhoAir * Math.pow(vmag,3) * dt) / (2 * PHYS.Q);
        f.mass += dM;
        if(f.mass <= PHYS.minFragmentMass){ f.alive = false; continue; }

        // recompute area assuming spherical fragments and same density
        const rhoMat = inpt.rho || 3000;
        const radius = Math.pow((3 * f.mass) / (4 * Math.PI * rhoMat), 1/3);
        f.area = Math.PI * radius * radius;

        // dynamic pressure for fragmentation (use rho * v^2)
        const dynP = rhoAir * vmag * vmag;
        if(dynP > PHYS.strength && f.mass > 10){
          // fragment
          const pieces = splitFragment(f.mass, false);
          f.alive = false;
          for(const m of pieces){
            const r = Math.pow((3 * m) / (4 * Math.PI * rhoMat), 1/3);
            simState.fragments.push({mass:m, area:Math.PI*r*r, vx:f.vx + (Math.random()-0.5)*200, vz:f.vz + (Math.random()-0.5)*200, altitude:f.altitude, posLat:f.posLat, posLng:f.posLng, alive:true});
          }
          logEvent('Fragmentation at alt '+Math.round(f.altitude)+' m → produced '+pieces.length+' pieces');
          continue;
        }

        // interceptors: trigger when fragment passes interceptor altitude
        if(interceptor.type !== 'none' && !f._intercepted && f.altitude <= interceptor.alt){
          f._intercepted = true;
          // delivered energy proportionate to fragment mass fraction
          const delivered = interceptor.energy * (f.mass / (mass + 1e-9));
          // fragment kinetic energy
          const KEf = 0.5 * f.mass * vmag * vmag;
          const bindingProxy = 0.2 * KEf; // energy needed to disperse
          if(delivered >= bindingProxy){
            // shatter into many small pieces
            const parts = splitFragment(f.mass, true);
            f.alive = false;
            for(const m of parts){ const r = Math.pow((3*m)/(4*Math.PI*rhoMat),1/3); simState.fragments.push({mass:m, area:Math.PI*r*r, vx:f.vx + (Math.random()-0.5)*400, vz:f.vz + (Math.random()-0.5)*400, altitude:f.altitude, posLat:f.posLat, posLng:f.posLng, alive:true}); }
            logEvent('Interceptor shatter at alt '+Math.round(f.altitude)+' m — produced '+parts.length+' fragments');
            continue;
          } else {
            // partial damage
            f.mass *= 0.6;
            logEvent('Interceptor partial hit at alt '+Math.round(f.altitude)+' m — mass reduced');
          }
        }

        // ground impact check
        if(f.altitude <= 0 && f.alive){
          // impact
          const vImpact = Math.sqrt(f.vx*f.vx + f.vz*f.vz);
          const KEimpact = 0.5 * f.mass * vImpact * vImpact;
          // store fragment impact in results array
          if(!simState._impacts) simState._impacts = [];
          simState._impacts.push({mass:f.mass, KE:KEimpact, lat:f.posLat, lng:f.posLng});
          f.alive = false;
          logEvent('Impact: mass '+Math.round(f.mass)+' kg, KE '+KEimpact.toExponential(3)+' J');
        }

      } // end for fragments

      // cleanup dead fragments
      simState.fragments = simState.fragments.filter(x=>x.alive);

      simState.time += dt;
      simState.data.push({t:simState.time, fragments:simState.fragments.length, totalMass: simState.fragments.reduce((a,b)=>a+b.mass,0)});

      // stop early if no fragments left
      if(simState.fragments.length === 0){
        // finalize
        finalizeSimulation(inpt);
        return;
      }

    } // end microsteps

    // schedule next frame
    requestAnimationFrame(step);
  }

  requestAnimationFrame(step);
}

function stepSimulation(){ if(!simState.running){ // start a paused simulation and advance a single tick
  simState.paused=false; runSimulation(); setTimeout(()=>{ simState.paused=true; },100); } else { // if running, toggle a short burst
  simState.paused=false; setTimeout(()=>{ simState.paused=true; },100); } }

/* --------------------------- FRAGMENTATION HELPERS --------------------------- */
function splitFragment(mass,shatter=false){
  const pieces = [];
  if(mass < 50) return [mass];
  const N = shatter? Math.min(30, Math.max(4, Math.round(mass/40))): Math.min(8, Math.max(2, Math.round(mass/200)));
  let remaining=mass;
  for(let i=0;i<N-1;i++){ const frac = Math.random()*0.4 + 0.05; const m = Math.max(1, remaining * frac); pieces.push(m); remaining -= m; }
  pieces.push(Math.max(1,remaining)); return pieces;
}

/* --------------------------- FINALIZE & GROUND EFFECTS --------------------------- */
function finalizeSimulation(inpt){
  simState.running = false;
  logEvent('Simulation finished — processing impacts');
  const impacts = (simState._impacts||[]);
  if(impacts.length === 0){ document.getElementById('keGround').innerText='0 J'; document.getElementById('tntEq').innerText='0 kt'; document.getElementById('popBefore').innerText='0'; document.getElementById('popAfter').innerText='0'; updateChart(simState.data); return; }

  const Eground = impacts.reduce((acc,i)=>acc + i.KE, 0);
  document.getElementById('keGround').innerText = Eground.toExponential(3) + ' J';
  const kt = Eground / PHYS.tntJ; document.getElementById('tntEq').innerText = kt.toFixed(3) + ' kt';

  // blast radii rules-of-thumb (tuned factors)
  const R_annih = Math.max(50, Math.pow(kt*1000,1/3) * 50); // meters
  const R_severe = R_annih * 2.5; const R_mod = R_severe * 2.5; const R_light = R_mod * 2.5;
  clearBlastLayers();
  drawBlast(R_light,{color:'yellow',fillOpacity:0.08});
  drawBlast(R_mod,{color:'orange',fillOpacity:0.12});
  drawBlast(R_severe,{color:'red',fillOpacity:0.18});
  drawBlast(R_annih,{color:'black',fillOpacity:0.6});

  // population estimation using simple circular areas
  const density = inpt.popDensity || 1000;
  const area_ann_km2 = Math.PI * Math.pow(R_annih/1000,2); const area_sev_km2 = Math.PI * Math.pow(R_severe/1000,2); const area_mod_km2 = Math.PI * Math.pow(R_mod/1000,2); const area_light_km2 = Math.PI * Math.pow(R_light/1000,2);
  const before = Math.round((area_ann_km2 + area_sev_km2 + area_mod_km2 + area_light_km2) * density);
  const cA = parseFloat(document.getElementById('cA').value) || 0.98; const cS = parseFloat(document.getElementById('cS').value) || 0.45; const cM = parseFloat(document.getElementById('cM').value) || 0.05; const cL = parseFloat(document.getElementById('cL').value) || 0.005;
  const deaths = Math.round(area_ann_km2 * density * cA + area_sev_km2 * density * cS + area_mod_km2 * density * cM + area_light_km2 * density * cL);

  document.getElementById('popBefore').innerText = before.toLocaleString(); document.getElementById('popAfter').innerText = deaths.toLocaleString();
  simState.results = {Eground,kt,R_annih,R_severe,R_mod,R_light,before,deaths};
  updateChart(simState.data);
}

/* --------------------------- EXPORT / SNAPSHOT --------------------------- */
function exportJSON(){ const inpt = gatherInput(); const payload = {input:inpt,results:simState.results, fragments:simState.fragments.map(f=>({mass:f.mass,altitude:f.altitude}))}; const blob = new Blob([JSON.stringify(payload,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='meteor-sim-export.json'; a.click(); URL.revokeObjectURL(url); logEvent('Exported JSON'); }

function takeSnapshot(){ const el = document.getElementById('map'); html2canvas(el).then(canvas=>{ const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download='meteor-snapshot.png'; a.click(); logEvent('Snapshot taken'); }); }

/* --------------------------- TIMELINE CHART --------------------------- */
function initChart(){ const ctx = document.getElementById('timelineChart').getContext('2d'); timelineChart = new Chart(ctx,{type:'line',data:{labels:[],datasets:[{label:'Total mass (kg)',data:[],fill:false},{label:'Fragments count',data:[],fill:false}]},options:{responsive:true,maintainAspectRatio:false,scales:{x:{display:true},y:{display:true}}}}); }
function updateChart(data){ if(!timelineChart) return; const labels = data.map(d=>d.t.toFixed(1)); timelineChart.data.labels = labels; timelineChart.data.datasets[0].data = data.map(d=>Number(d.totalMass.toFixed(2))); timelineChart.data.datasets[1].data = data.map(d=>d.fragments); timelineChart.update(); }

/* --------------------------- BOOT --------------------------- */
window.onload = init;
</script>
</body>
</html>
